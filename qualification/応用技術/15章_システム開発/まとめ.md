## 15-1 ソフトウェアライフサイクルと共通フレーム
- 機能要件
  - ヒアリングで、利用者から得られる要求事項のこと
- 非機能要件
  - システム基盤側の要件
  - OS・ミドルウェア・ハードウェア構成・ネットワーク機器など...
- 開発コストの見積もり
  - プログラムステップ法
    - ソースコードの行数により開発コストを算出する
  - ファンクションポイント法
    - 表示画面、印刷する帳票、出力ファイルなどの個数から開発コストを算出する。
## 15-2 システムの開発手法
- スパイラルモデル
  - システムを複数のサブシステムに分割して、それぞれのサブシステムごとに開発を進めていく手法。個々のサブシステムはウォータフォールモデルで進められる。
- ウォーターフォールモデル
  - 要件定義からプログラミング、テストを順番に進めていく。
- プロトタイプモデル
  - 開発初期の段階で試作品を作り、利用者に確認してもらい開発側とのずれを防ぐ手法。
- 設計
  - 外部設計
    - 利用者から見た設計(ユーザーインターフェース)を行う
  - 内部設計
    - 開発者から見た設計(物理データ設計など)を行う
- テスト
  - 単体テスト
    - モジュールレベルの動作確認
  - 結合テスト
    - モジュールを結合させた状態での動作確認
  - システムテスト
    - システム全体を稼働させての動作確認・負荷試験
  - 運用テスト
    - 実際の運用と同じ条件下でテストを行う
## 15-3 アジャイル開発
- RAD(Rapid Application Development)
  - 迅速なアプリケーション開発。少人数構成のチームを組み、開発支援ツールを活用。
  - タイムボックス
    - RADでは、プロトタイプ作成→評価を繰り返すが、無限に繰り返されないように期限を設ける。
- アジャイル開発
  - 実時間反復単位で迅速に開発を行う手法。
- XP(extreme programming)
  - ソフトウェアが仕様。ドキュメントは二の次。
  - 変更は柔軟に行う。
  - 5つのプラクティス
    - テスト駆動開発
      - 先にテストを定めて、テストをパスするように実装を行う。
    - ペアプログラミング
      - 2人1組でプログラミングを行う。1人がコードを書き、1人がその検証役となる。
    - リファクタリング
      - 完成したプログラムでも内部コードを随時修正する。
- リバースエンジニアリング
  - 既存ソフトウェアの動作を解析することで、プログラムの使用やソースコードを導き出すこと
- フォワードエンジニアリング
  - リバースエンジニアリングをもとに新しいソフトウェアの開発を行うこと。
- マッシュアップ
  - 公開されている複数のサービスを組み合わせて新しいサービスを作り出す手法

## 15-4 業務のモデル化
- モデル化とは
  - 業務プロセスを抽象化して視覚的に表すこと。
  - DFD、E-R図が代表的。
- DFD(Data Flow Diagram)
  - 新規システムのモデル化を行う手順
    - 現物理モデルの作成
      - 現在の業務をありのままにモデル化
      - DFDで表す
    - 現論理モデルの作成
      - 現物理モデルを元に重複した業務を統合する
      - 無駄を省く
    - 新論理モデルの作成
      - 現状の論理モデルに新規システムの要件を加える
    - 新物理モデルの作成
      - 新論理モデルに物理的な要件を反映させて新物理モデルを作成
- E-R図(Entitiy, Relationship)
  - 1対1、1対多、多対多を表す

## ユニバーサルデザイン
- より多くの人が利用可能であるようにデザインすること
- 7原則
  - 公平性
  - 自由・柔軟性
  - 単純性
  - わかりやすさ
  - 安全性
  - 体への負担の少なさ
  - 空間の確保

- チェックデジット
  - 誤入力を判定するためにコードへ付加された数字
    - 例えば、9612345というチェックデジットが含まれたコードがあるとすると、
      - 先頭6文字を足すと25
      - それを10で割った数を末尾(5)にするというルールづけをする。
      - この5を設けることをチェックデジットとする。

## モジュールの分割
- プログラムの構造化設計
  - 各プログラムをモジュールという単位に分解・階層化させること
- モジュールに分ける利点
  - 作業分担ができ、並行してプログラミング作業を進めることができる
  - 再利用が容易
  - 修正がモジュールだけですむ
- モジュールの分割技法
  - STS分割法
    - プログラムを入力処理(source)、変換処理(Transform)、出力処理(Sink)の3つのモジュール構造に分割する方法
  - トランザクション分割法
    - プログラムを一連の処理(トランザクション)単位に分割する方法
  - 共通機能分割法
    - プログラムの共通機能をモジュールとして分割する方法
- モジュール強度
  - モジュール内の機能が、内部でどのように関連づいているかを示す尺度。
  - どれだけ機能的に特化できているか
- モジュール結合度
  - モジュールの結合度は弱いほど、モジュールの独立性が高くて好ましい。

## オブジェクト志向プログラミング
- オブジェクト指向
  - 処理の対象をオブジェクトという概念で捉えて、データとそれに対する処理(メソッド)をひとまとめにしたもの
  - モジュールの独立性を高めることができ、保守しやすいプログラムを作ることができる。
- カプセル化
  - オブジェクト内部の構造はわからず、外部から参照できないようになる。
- クラス
  - オブジェクトが持つ性質のこと
  - このオブジェクトはこういう仕様...などを定義する
- インスタンス
  - 設計図に具体的な属性値を与えてメモリ上に生成して実体化させたもの
- 階層構造
  - 下位クラスは上位クラスのデータやメソッドを受け継ぐことができる。
  - 例えば、ボタンのクラスがあり、特定のボタンにホバーしたら色を変化させる機能を追加したい場合、ボタンクラスを引き継いで追加でhoverの処理を追加する。
  - 汎化と特化(is a関係)
    - 上位クラスがスーパークラス、下位クラスがサブクラスの関係を保つには、「汎化と特化」の関係が必要
    - 汎化
      - 下位クラスが持つ共通の性質を上記クラスとして定義する
    - 特化
      - 抽象的な上位クラスを具体的なクラスとして定義。
  - 集約と分解(part of関係)
    - 下位クラスは上位クラスの一部であるという関係
- 継承
  - 上記の階層構造で、メソッドの引き継ぎのことを継承という。
- ポリモーフィズム
  - 同じメッセージを複数のオブジェクトに送るとそれぞれが独立した固有の処理を行う
## UML(Unified Modeling Language)
- UML
  - 複数人で設計モデルを共有してコミュニケーションを図るための手段
  - クラス図(p.734)
    - クラスの定義や関連付けを行う
  - ユースケース図(p.734)
    - 利用者視点でシステムが要求に対してどのように振る舞うかを示す図。
    - アクターとユースケースが存在する
  - アクティビティ図(p.735)
    - 業務や処理のフローを表す図。
    - 処理の開始から終了までの一連の流れを実行される順番通りに図示。
  - シーケンス図(p.735)
    - オブジェクト間のやり取りを時系列に沿って表す図。

## テスト
- テストの流れ
  - 単体テスト
    - 各モジュールごとにテストを行う
  - 結合テスト
    - モジュールをつなぎ合わせて行う
  - システムテスト
    - システム全体を対象に、要求された機能がちゃんと動くかの機能テスト
    - 処理能力は十分かの性能テスト
    - 高い負荷の下でも問題ないかの負荷テスト
- ブラックボックステストとホワイトボックステスト
  - ブラックボックステスト
    - モジュールの内部構造は意識せず、入力に対して適切な出力がされるかを検証する。
  - ホワイトボックステスト
    - モジュールの内部構造が正しく作られているかをチェック。
